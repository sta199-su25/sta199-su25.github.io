{
  "hash": "1384b6b54ba5993636a64d1dd9c525fa",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"More logistic regression\"\nsubtitle: \"Lecture 19\"\ndate: \"2025-6-19\"\nformat: \n  revealjs:\n    output-file: 19-logistic-2-slides.html\n    pdf-separate-fragments: true\nauto-stretch: false\n---\n\n## While you wait... {.smaller}\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n::: appex\n-   Go to your `ae` project in RStudio.\n\n-   Make sure all of your changes up to this point are committed and pushed, i.e., there's nothing left in your Git pane.\n\n-   Click Pull to get today's application exercise file: *ae\\-14\\-spam\\-filter\\.qmd*.\n\n-   Wait till the you're prompted to work on the application exercise during class before editing the file.\n:::\n\n## Announcements\n\n-   Office hours tomorrow will be about 20 mins short (1:00 - 2:40).\n    I will be there a little before 1:00 if you want to come early!\n\n-   Make appointment to see in-class exams/talk through problems you're stuck on.\n    Remember, final exam is cumulative!!\n\n## Project Reminders\n\n-   Milestone 3 due Friday night!!\n\n-   Once your project website renders, **you still need to push** for the changes to show up!!!\n\n## Logistic Regression: Recap {.smaller}\n\n*Goal*: modelling/predicting ***binary*** outcome $y$\n\n-   Idea: Model the probability $p$ that $y = 1$\n\n. . .\n\n-   S-curve for the probability of success $p=P(y=1)$:\n\n$$\n    \\hat{p} = \\frac{e^{b_0+b_1x}}{1+e^{b_0+b_1x}}.\n   $$\n\n. . .\n\n-   Linear model for the log-odds:\n\n$$\n    \\log\\left(\\frac{\\hat{p}}{1-\\hat{p}}\\right) = b_0+b_1x.\n  $$\n\n## R syntax is mostly unchanged {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsimple_logistic_fit <- logistic_reg() |>\n  fit(spam ~ exclaim_mess, data = email)\n\ntidy(simple_logistic_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term          estimate std.error statistic p.value\n  <chr>            <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)  -2.27      0.0553     -41.1     0    \n2 exclaim_mess  0.000272  0.000949     0.287   0.774\n```\n\n\n:::\n:::\n\n\n. . .\n\nFitted equation for the log-odds:\n\n$$\n\\log\\left(\\frac{\\hat{p}}{1-\\hat{p}}\\right)\n=\n-2.27\n+\n0.000272\\times exclaim~mess\n$$\n\n. . .\n\nInterpretations are strange and delicate.\n\n\n## Questions??? Review??? Anything?! {.smaller}\n\n## Let's Practice\n\nAE-14: Watch now, fill in later (optional!)\n\n## Goal {.smaller}\n\n-   We will build a spam filter from email data\n-   The data come from incoming emails in David Diez's (one of the authors of OpenIntro textbooks) Gmail account for the first three months of 2012\n-   User number of exclamation marks in an email address (`exclaim_mess`) to predict whether or not the email is spam (`spam`: 1 if spam; 0 if not)\n\n## Data {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(email)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 3,921\nColumns: 21\n$ spam         <fct> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ to_multiple  <fct> 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ from         <fct> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ cc           <int> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 2, 1,…\n$ sent_email   <fct> 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1,…\n$ time         <dttm> 2012-01-01 01:16:41, 2012-01-01 02:03:59, 2012…\n$ image        <dbl> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ attach       <dbl> 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ dollar       <dbl> 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,…\n$ winner       <fct> no, no, no, no, no, no, no, no, no, no, no, no,…\n$ inherit      <dbl> 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ viagra       <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ password     <dbl> 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ num_char     <dbl> 11.370, 10.504, 7.773, 13.256, 1.231, 1.091, 4.…\n$ line_breaks  <int> 202, 202, 192, 255, 29, 25, 193, 237, 69, 68, 2…\n$ format       <fct> 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1,…\n$ re_subj      <fct> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1,…\n$ exclaim_subj <dbl> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ urgent_subj  <fct> 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ exclaim_mess <dbl> 0, 1, 6, 48, 1, 1, 1, 18, 1, 0, 2, 1, 0, 10, 4,…\n$ number       <fct> big, small, small, small, none, none, big, smal…\n```\n\n\n:::\n:::\n\n\n## EDA (Ex. 1) {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](19-logistic-2_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n## EDA (Ex. 1) {.smaller}\n\nMean exclamation points by spam/not spam:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  spam  mean_ep\n  <fct>   <dbl>\n1 0        6.51\n2 1        7.32\n```\n\n\n:::\n:::\n\n\n## Linear Model (Ex. 2) {.smaller}\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](19-logistic-2_files/figure-revealjs/unnamed-chunk-7-1.png){width=960}\n:::\n:::\n\n\nThis makes no sense at all.\n\n## Fit Logistic Regression (Ex. 3) {.smaller}\n\nThis is what we have seen already!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_exl_fit <- logistic_reg() |>\n  fit(spam ~ exclaim_mess, data = email)\n\ntidy(spam_exl_fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  term          estimate std.error statistic p.value\n  <chr>            <dbl>     <dbl>     <dbl>   <dbl>\n1 (Intercept)  -2.27      0.0553     -41.1     0    \n2 exclaim_mess  0.000272  0.000949     0.287   0.774\n```\n\n\n:::\n:::\n\n\n$$\n\\log\\left(\\frac{\\hat{p}}{1-\\hat{p}}\\right)\n=\n-2.27\n+\n0.000272\\times exclaim~mess\n$$\n\n## Goal: Predict!! (Ex. 4a) {.smaller}\n\n*What is the probability the email is spam if it contains 10 exclamation points??* Use `predict`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_email <- tibble(\n  exclaim_mess = 10\n  )\n\nnew_email\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  exclaim_mess\n         <dbl>\n1           10\n```\n\n\n:::\n:::\n\n\n## Goal: Predict!! (Ex. 4a) {.smaller}\n\n*What is the probability the email is spam if it contains 10 exclamation points??* Use `predict`!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnew_email <- tibble(\n  exclaim_mess = 10\n  )\n\npredict(spam_exl_fit, new_data = new_email, type = \"prob\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  .pred_0 .pred_1\n    <dbl>   <dbl>\n1   0.906  0.0937\n```\n\n\n:::\n:::\n\n\n## Goal: Predict!! (Ex. 4b) {.smaller}\n\n*A probability is nice, but we want an actual decision. Classify the email!!!*\n\n\n::: {.cell}\n\n```{.r .cell-code}\npredict(spam_exl_fit, new_data = new_email, type = \"class\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 1\n  .pred_class\n  <fct>      \n1 0          \n```\n\n\n:::\n:::\n\n\n. . . \n\nThe default behavior is to threshold the probabilities by 0.5.\n\n## Let's use more data (Ex. 5a) {.smaller}\n\nWhy limit ourselves to using exclamation points???\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_fit <- logistic_reg() |>\n  fit(spam ~ time + exclaim_mess + line_breaks, data = email)\n```\n:::\n\n\n\n## Let's use even more data (Ex. 5b) {.smaller}\n\nWhat about all the predictors???\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_all_fit <- logistic_reg() |>\n  fit(spam ~ ., data = email)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: glm.fit: fitted probabilities numerically 0 or 1 occurred\n```\n\n\n:::\n:::\n\n\n\nThe `.` means _all other variables_ .\n\n## Is our model good??? (Ex. 5c) {.smaller}\n-  Goal is to evaluate how good our model is. \n-  If you're coding along: pause!! We're going to review concepts first!!\n\n## Reminder: Classification Error  {.smaller}\n\nThere are two kinds of mistakes:\n\n![](images/18/confusion-matrix.png)\n\nWe want to avoid both, but there's a trade-off.\n\n## Terms: False negative and positive rates  {.smaller}\n\n-   **False negative rate** is the *proportion* of actual positives that were classified as negatives.\n\n-   **False positive rate** is the *proportion* of actual negatives that were classified as positives.\n\n. . . \n\n::: callout-tip\nWe want these to be low!\n:::\n\n## Terms: False negative and positive rates {.smaller}\n\n-   **False negative rate**  = $\\frac{FN}{FN + TP}$ \n\n-   **False positive rate**  = $\\frac{FP}{FP + TN}$ \n\n![](images/18/confusion-matrix.png)\n\n## Term: Sensitivity {.smaller}\n\n**Sensitivity** is the *proportion* of actual positives that were correctly classified as positive.\n\n-   Also known as **true positive rate** and **recall**\n\n-  Specificity = $\\frac{FN}{FN + TP}$ \n\n-   Sensitivity = 1 − False negative rate\n\n-   Useful when false negatives are more \"expensive\" than false positives\n\n::: callout-tip\nWe want this to be high!\n:::\n\n\n## Term: Specificity {.smaller}\n\n**Specificity** is the *proportion* of actual negatives that were correctly classified as negative\n\n-   Also known as **true negative rate**\n\n-   Specificity = $\\frac{TN}{FP + TN}$ \n\n-   Specificity = 1 − False positive rate\n\n-   Useful when false positives are more \"expensive\" than false negatives\n\n::: callout-tip\nWe want this to be high!\n:::\n\n\n## The augment function {.smaller}\n\nThe `augment` function takes a data frame and \"augments\" it by adding three new columns on the left that describe the model predictions for each row:\n\n:::incremental\n-   `.pred_class`: model prediction ($\\hat{y}$) based on a 50% threshold;\n-   `.pred_0`: model estimate of $P(y=0)$;\n-   `.pred_1`: model estimate of $P(y=1) = 1 - P(y = 0)$.\n:::\n\n## The augment function {.smaller}\n\nThe `augment` function takes a data frame and \"augments\" it by adding three new columns on the left that describe the model predictions for each row:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_aug_all <- augment(spam_all_fit, email)\nspam_aug_all\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3,921 × 24\n   .pred_class .pred_0  .pred_1 spam  to_multiple from     cc\n   <fct>         <dbl>    <dbl> <fct> <fct>       <fct> <int>\n 1 0             0.867 1.33e- 1 0     0           1         0\n 2 0             0.943 5.70e- 2 0     0           1         0\n 3 0             0.942 5.78e- 2 0     0           1         0\n 4 0             0.920 7.96e- 2 0     0           1         0\n 5 0             0.903 9.74e- 2 0     0           1         0\n 6 0             0.901 9.87e- 2 0     0           1         0\n 7 0             1.00  7.89e-12 0     1           1         0\n 8 0             1.00  1.24e-12 0     1           1         1\n 9 0             0.862 1.38e- 1 0     0           1         0\n10 0             0.922 7.76e- 2 0     0           1         0\n# ℹ 3,911 more rows\n# ℹ 17 more variables: sent_email <fct>, time <dttm>, image <dbl>,\n#   attach <dbl>, dollar <dbl>, winner <fct>, inherit <dbl>,\n#   viagra <dbl>, password <dbl>, num_char <dbl>, line_breaks <int>,\n#   format <fct>, re_subj <fct>, exclaim_subj <dbl>,\n#   urgent_subj <fct>, exclaim_mess <dbl>, number <fct>\n```\n\n\n:::\n:::\n\n\n## Calculating the error rates (5c) {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_aug_all |>\n  count(spam, .pred_class) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  spam  .pred_class     n\n  <fct> <fct>       <int>\n1 0     0            3521\n2 0     1              33\n3 1     0             299\n4 1     1              68\n```\n\n\n:::\n:::\n\n\n## Calculating the error rates  (5c) {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_aug_all |>\n  count(spam, .pred_class) |>\n  group_by(spam)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n# Groups:   spam [2]\n  spam  .pred_class     n\n  <fct> <fct>       <int>\n1 0     0            3521\n2 0     1              33\n3 1     0             299\n4 1     1              68\n```\n\n\n:::\n:::\n\n\n## Calculating the error rates  (5c) {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_aug_all |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n       p\n  <fct> <fct>       <int>   <dbl>\n1 0     0            3521 0.991  \n2 0     1              33 0.00929\n3 1     0             299 0.815  \n4 1     1              68 0.185  \n```\n\n\n:::\n:::\n\n\n## Calculating the error rates  (5c) {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspam_aug_all |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n),\n         decision = case_when(\n            spam == \"0\" & .pred_class == \"0\" ~ \"True negative\",\n            spam == \"0\" & .pred_class == \"1\" ~ \"False positive\",\n            spam == \"1\" & .pred_class == \"0\" ~ \"False negative\",\n            spam == \"1\" & .pred_class == \"1\" ~ \"True positive\"\n        ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 5\n# Groups:   spam [2]\n  spam  .pred_class     n       p decision      \n  <fct> <fct>       <int>   <dbl> <chr>         \n1 0     0            3521 0.991   True negative \n2 0     1              33 0.00929 False positive\n3 1     0             299 0.815   False negative\n4 1     1              68 0.185   True positive \n```\n\n\n:::\n:::\n\n\n\n## But wait! {.smaller}\n\nIf we change the classification threshold, we change the classifications, and we change the error rates:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\nspam_aug_all |>\n  mutate(\n    .pred_class = if_else(.pred_1 <= 0.25, 0, 1)\n  ) |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n      p\n  <fct>       <dbl> <int>  <dbl>\n1 0               0  3263 0.918 \n2 0               1   291 0.0819\n3 1               0   172 0.469 \n4 1               1   195 0.531 \n```\n\n\n:::\n:::\n\n\n## Classification threshold: 0.00 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\nspam_aug_all |>\n  mutate(\n    .pred_class = if_else(.pred_1 <= 0.00, 0, 1)\n  ) |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n     p\n  <fct>       <dbl> <int> <dbl>\n1 0               1  3554     1\n2 1               1   367     1\n```\n\n\n:::\n:::\n\n\n## Classification threshold: 0.25 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\nspam_aug_all |>\n  mutate(\n    .pred_class = if_else(.pred_1 <= 0.25, 0, 1)\n  ) |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n      p\n  <fct>       <dbl> <int>  <dbl>\n1 0               0  3263 0.918 \n2 0               1   291 0.0819\n3 1               0   172 0.469 \n4 1               1   195 0.531 \n```\n\n\n:::\n:::\n\n\n## Classification threshold: 0.5 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\nspam_aug_all |>\n  mutate(\n    .pred_class = if_else(.pred_1 <= 0.50, 0, 1)\n  ) |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n       p\n  <fct>       <dbl> <int>   <dbl>\n1 0               0  3521 0.991  \n2 0               1    33 0.00929\n3 1               0   299 0.815  \n4 1               1    68 0.185  \n```\n\n\n:::\n:::\n\n\n## Classification threshold: 0.75 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\nspam_aug_all |>\n  mutate(\n    .pred_class = if_else(.pred_1 <= 0.75, 0, 1)\n  ) |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n       p\n  <fct>       <dbl> <int>   <dbl>\n1 0               0  3544 0.997  \n2 0               1    10 0.00281\n3 1               0   339 0.924  \n4 1               1    28 0.0763 \n```\n\n\n:::\n:::\n\n\n## Classification threshold: 1.00 {.smaller}\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\nspam_aug_all |>\n  mutate(\n    .pred_class = if_else(.pred_1 <= 1.00, 0, 1)\n  ) |>\n  count(spam, .pred_class) |>\n  group_by(spam) |>\n  mutate(p = n / sum(n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n# Groups:   spam [2]\n  spam  .pred_class     n     p\n  <fct>       <dbl> <int> <dbl>\n1 0               0  3554     1\n2 1               0   367     1\n```\n\n\n:::\n:::\n\n\n\n## Let's plot these error rates\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](19-logistic-2_files/figure-revealjs/unnamed-chunk-25-1.png){width=960}\n:::\n:::\n\n",
    "supporting": [
      "19-logistic-2_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}