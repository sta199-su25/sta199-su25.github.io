{
  "hash": "2f8d981b66507caf0c2573d02b6ca9cb",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data types and classes\"\nsubtitle: \"Lecture 8\"\ndate: \"May 27, 2025\"\nformat: \n  revealjs:\n    output-file: 08-data-types-slides.html\nauto-stretch: false\n---\n\n\n::: {.cell}\n\n:::\n\n\n## Announcements\n\n-   Exam 1 in class next week on Tuesday -- cheat sheet (1 page, both sides, hand-written or typed, must be prepared by you)\n-   Exam 1 take home starts after class on **Tuesday**, due at 9:30 AM on **Wednesday** (open resources, internet, etc., closed to other humans) - I nor Katie nor Mary will be available to answer questions!!\n\n## Study tips for the exam\n\n-   Review lectures/readings/labs/AEs\n-   Make sure you understand why code has the output it does\n-   Try to outline the process for answering each of the lab questions\n-   Lab 3 will cover most of what we have done so far - think of this as a type of review!\n-   In class review coming on Friday\n\n# Types and classes\n\n## Types and classes\n\n-   Type is how an object is stored in memory\n-   \n\n## Common data types\n\n::: columns\n::: {.column width=\"50%\"}\nYou'll commonly encounter:\n\n-   `logical`\n-   `integer`\n-   `double`\n-   `character`\n:::\n\n::: {.column width=\"50%\"}\nYou'll less commonly encounter:\n\n-   `list`\n-   `NULL`\n-   `complex`\n-   `raw`\n:::\n:::\n\n## Logical and Character {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n**Logical:** Boolean `TRUE` / `FALSE` values\n\n-   `<dbl>`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n**Character:** Character strings; in quotes\n\n-   \\`\\<chr\\>\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"Hello!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"TRUE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Numeric: Double and integer {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n**Double**: floating point numerical values (default numerical type)\n\n-   \\`\\<dbl\\>\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(2.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n**Integer**: integer numerical values; indicated with an `L`\n\n-   \\`\\<int\\>\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Type Compatibility {.smaller}\n\nCan you use different types of data together?\nSometimes... but be careful!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"3\" + 3\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"3\" + 3: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3L + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(3L + 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(TRUE + 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n## Concatenation {.smaller}\n\n**Vectors** are constructed using the `c` function\n\n::: columns\n::: {.column width=\"50%\"}\n-   **Double** vector:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(1, 2, 3, 5)\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"double\"\n    ```\n    \n    \n    :::\n    :::\n\n\n-   **Integer** vectors:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(1L, 2L, 3L, 5L)\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"integer\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\"}\n-   **Character** vector:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(\"1\", \"2\", \"3\", \"5\")\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    :::\n\n\n-   **Logical** vectors:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(TRUE, FALSE, FALSE)\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"logical\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Converting between types {.smaller}\n\n::: hand\nwithout intention...\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2, \"Just this one!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"              \"Just this one!\"\n```\n\n\n:::\n:::\n\n\n<br>\n\nR will happily convert between various types without complaint when different types of data are concatenated in a vector.\nThis is NOT always a good thing.\n\n## Converting between types {.smaller}\n\n::: hand\nwithout intention...\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(FALSE, 3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 3\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1.2, 3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 3.0\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2L, \"two\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"   \"two\"\n```\n\n\n:::\n:::\n\n\n# Converting between types\n\n::: hand\nwith intention...\n:::\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.character(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Converting between types\n\n::: hand\nwith intention...\n:::\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.numeric(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Explicit vs. implicit coercion {.smaller}\n\n::: columns\n::: {.column width=\"49%\"}\n**Explicit coercion:**\n\nWhen you call a function like:\n\n-   `as.logical()`\n\n-   `as.numeric()`\n\n-   `as.integer()`\n\n-   `as.double()`\n\n-   `as.character()`.\n:::\n\n::: {.column .fragment width=\"49%\"}\n**Implicit coercion:**\n\nHappens when you use a vector in a specific context that expects a certain type of vector.\n:::\n:::\n\n# Data classes\n\n## Data classes {.smaller}\n\n::: incremental\n-   Data types are like Lego building blocks\n-   We can stick them together to build more complicated constructs, e.g. *representations of data*\n-   The **class** determines this construct\n-   Examples: factors, dates, and data frames\n:::\n\n## Data frames {.smaller}\n\nWe can think of data frames like like vectors of equal length glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:2, y = 3:4)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 4\n```\n\n\n:::\n:::\n\n\n::: columns\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n:::\n\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n-   When we use the `pull()` function, we extract a vector from the data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  pull(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n:::\n\n\n\n## Factors {.smaller}\n\nfsu R uses factors to handle categorical variables, variables that have a fixed and known set of possible values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass_years <- factor(\n  c(\n    \"First-year\", \"Sophomore\", \"Sophomore\", \"Senior\", \"Junior\"\n    )\n  )\nclass_years\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] First-year Sophomore  Sophomore  Senior     Junior    \nLevels: First-year Junior Senior Sophomore\n```\n\n\n:::\n:::\n\n\n::: columns\n::: {.column .fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(class_years)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(class_years)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## More on factors\n\nWe can think of factors like character (level labels) and an integer (level numbers) glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(class_years)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 4 levels \"First-year\",\"Junior\",..: 1 4 4 3 2\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(class_years)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 4 4 3 2\n```\n\n\n:::\n:::\n\n\n## Dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- as.Date(\"2024-09-24\")\ntoday\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2024-09-24\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n## More on dates\n\nWe can think of dates like an integer (the number of days since the origin, 1 Jan 1970) and an integer (the origin) glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 19990\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(today) / 365 # roughly 55 yrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 54.76712\n```\n\n\n:::\n:::\n\n\n# Application exercise\n\n## `ae-07-population-types`\n\n::: appex\n-   Go to the project navigator in RStudio (top right corner of your RStudio window) and open the project called `ae`.\n\n-   If there are any uncommitted files, commit them, and then click **Pull**.\n\n-   Open the file called `ae-07-population-types.qmd` and render it.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}