{
  "hash": "80adfb223659a265d116f22924e424ba",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data types and classes\"\nsubtitle: \"Lecture 8\"\ndate: \"May 27, 2025\"\nformat: \n  revealjs:\n    output-file: 08-data-types-slides.html\nauto-stretch: false\n---\n\n\n::: {.cell}\n\n:::\n\n\n## Announcements\n\n-   Exam 1 in class next week on Tuesday -- cheat sheet (1 page, both sides, hand-written or typed, must be prepared by you)\n-   Exam 1 take home starts after class on **Tuesday**, due at 9:30 AM on **Wednesday** (open resources, internet, etc., closed to other humans)\n\n## Study tips for the exam\n\n-   Review lectures/readings/labs/AEs\n-   Make sure you understand [***why***]{.underline} code has the output it does\n-   Lab 3 will cover most of what we have done so far - think of this as a type of review!\n-   General practice/ in class review coming on Friday!\n\n# Types and classes\n\n## Types and classes\n\nAn object's *type* indicates how it is stored in memory.\n\n## Common data types\n\n::: columns\n::: {.column width=\"50%\"}\nYou'll commonly encounter:\n\n-   `logical`\n-   `integer`\n-   `double`\n-   `character`\n:::\n\n::: {.column width=\"50%\"}\nYou'll less commonly encounter:\n\n-   `list`\n-   `NULL`\n-   `complex`\n-   `raw`\n:::\n:::\n\n## Logical and Character {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n**Logical:** Boolean `TRUE` / `FALSE` values\n\n-   `<dbl>`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n**Character:** Character strings; in quotes\n\n-   \\`\\<chr\\>\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"Hello!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"TRUE\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Numeric: Double and integer {.smaller}\n\n::: columns\n::: {.column width=\"50%\"}\n**Double**: floating point numerical values (default numerical type)\n\n-   \\`\\<dbl\\>\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(2.5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n**Integer**: integer numerical values; indicated with an `L`\n\n-   \\`\\<int\\>\\`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Type Compatibility {.smaller}\n\nCan you use different types of data together?\nSometimes... but be careful!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\"3\" + 3\n```\n\n::: {.cell-output .cell-output-error}\n\n```\nError in \"3\" + 3: non-numeric argument to binary operator\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n3L + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(3L + 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTRUE + 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(TRUE + 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n## Concatenation {.smaller}\n\n**Vectors** are constructed using the `c` function\n\n::: columns\n::: {.column width=\"50%\"}\n-   **Double** vector:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(1, 2, 3, 5)\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"double\"\n    ```\n    \n    \n    :::\n    :::\n\n\n-   **Integer** vectors:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(1L, 2L, 3L, 5L)\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"integer\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n\n::: {.column width=\"50%\"}\n-   **Character** vector:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(\"1\", \"2\", \"3\", \"5\")\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"character\"\n    ```\n    \n    \n    :::\n    :::\n\n\n-   **Logical** vectors:\n\n\n    ::: {.cell}\n    \n    ```{.r .cell-code}\n    x <- c(TRUE, FALSE, FALSE)\n    typeof(x)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    \n    ```\n    [1] \"logical\"\n    ```\n    \n    \n    :::\n    :::\n\n:::\n:::\n\n## Converting between types {.smaller}\n\n::: hand\nwithout intention...\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2, \"Just this one!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"              \"Just this one!\"\n```\n\n\n:::\n:::\n\n\n<br>\n\nR will happily convert between various types without complaint when different types of data are concatenated in a vector.\nThis is NOT always a good thing.\n\n## Converting between types {.smaller}\n\n::: hand\nwithout intention...\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(FALSE, 3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 3\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1.2, 3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 3.0\n```\n\n\n:::\n:::\n\n\n<br>\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(2L, \"two\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"   \"two\"\n```\n\n\n:::\n:::\n\n\n## Converting between types\n\n::: hand\nwith intention...\n:::\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.character(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Converting between types\n\n::: hand\nwith intention...\n:::\n\n::: columns\n::: {.column width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment width=\"49%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.numeric(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Explicit vs. implicit coercion {.smaller}\n\n::: columns\n::: {.column width=\"49%\"}\n**Explicit coercion:**\n\nWhen you call a function like:\n\n-   `as.logical()`\n\n-   `as.numeric()`\n\n-   `as.integer()`\n\n-   `as.double()`\n\n-   `as.character()`.\n:::\n\n::: {.column .fragment width=\"49%\"}\n**Implicit coercion:**\n\nHappens when you use a vector in a specific context that expects a certain type of vector.\n:::\n:::\n\n# Data classes\n\n## Data classes {.smaller}\n\n::: incremental\n-   Data types are like Lego building blocks\n-   We can stick them together to build more complicated constructs, e.g. *representations of data*\n-   The **class** determines this construct\n-   Examples: factors, dates, and data frames\n:::\n\n## Data frames {.smaller}\n\nWe can think of data frames like like vectors of equal length glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:2, y = 3:4)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 4\n```\n\n\n:::\n:::\n\n\n::: columns\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n:::\n\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## Data frames {.smaller}\n\nWe can think of data frames like like vectors of equal length glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(x = 1:2, y = 3:4)\ndf\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  x y\n1 1 3\n2 2 4\n```\n\n\n:::\n:::\n\n\n::: columns\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"list\"\n```\n\n\n:::\n:::\n\n:::\n\n::: column\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"data.frame\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n-   When we use the `pull()` function, we extract a vector from the data frame\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |>\n  pull(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 4\n```\n\n\n:::\n:::\n\n\n## Dates\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntoday <- as.Date(\"2025-05-27\")\ntoday\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2025-05-27\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n## More on dates\n\nWe can think of dates like an integer (the number of days since the origin, 1 Jan 1970) and an integer (the origin) glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(today)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 20235\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(today) / 365 # roughly 55 yrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55.43836\n```\n\n\n:::\n:::\n\n\n## Factors {.smaller}\n\nR uses **factors** to handle **categorical variables** with a fixed and known set of possible values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmonths <- c(\"June\", \"July\", \"June\", \"August\", \"June\")\nmonths_factor <- factor(months)\nmonths_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] June   July   June   August June  \nLevels: August July June\n```\n\n\n:::\n:::\n\n\n::: columns\n::: {.column .fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(months_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n:::\n\n::: {.column .fragment}\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(months_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n:::\n:::\n\n## More on factors\n\nWe can think of factors like character (level labels) and an integer (level numbers) glued together\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(months_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 3 levels \"August\",\"July\",..: 3 2 3 1 3\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas.integer(months_factor)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3 2 3 1 3\n```\n\n\n:::\n:::\n\n\n## More on factors {.smaller}\n\nWe can use the **forcats** package (in **tidyverse**) to work with factors!\n\nSome commonly used functions are:\n\n-   fct_relevel(): reorder factors by hand\n\n-   fct_reorder(): reorder factors by another variable\n\n-   fct_infreq(): reorder factors by frequency\n\n-   fct_rev(): reorder factors by reversing\n\n## Example Factor Re-Order\n\n\n::: {.cell}\n\n```{.r .cell-code}\namounts <- c(\"low\", \"medium\", \"high\", \"high\", \"medium\")\namounts_factor <- factor(amounts)\namounts_factor\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] low    medium high   high   medium\nLevels: high low medium\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfct_relevel(amounts_factor, c(\"low\", \"medium\", \"high\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] low    medium high   high   medium\nLevels: low medium high\n```\n\n\n:::\n:::\n\n\n# Application exercise\n\n## AE 08: Working with Factors\n",
    "supporting": [
      "08-data-types_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}